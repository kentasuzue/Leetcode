class Solution:
    
    import itertools
    
    def combinationSum3(self, k: int, n: int) -> List[List[int]]:
        
        def backtrack(curr, currSum, nextIntBegin, size):
            
            # print(f"curr={curr} currSum={currSum} nextIntBegin={nextIntBegin} size={size}")
            
            if size == k:
                if currSum == n:
                    answers.append(curr[:]) # curr[:] instead of curr will make a copy
                    # print(curr[:])
                    # print(answers)
                    # print("bingo")
                return
            
            # give up if sum is too large
            if currSum >= n:
                return

            remainingPossibleNumbers = 10 - nextIntBegin
            remainingNumbersToFill = k - size
            
            # give up on curr if not enough numbers left to fill out an answer
            if remainingPossibleNumbers < remainingNumbersToFill:
                return
            
            for nextInt in range(nextIntBegin, 10): # iterate up to 9, the highest number
                curr.append(nextInt)
                currSum += nextInt
                size += 1
                backtrack(curr, currSum, nextInt + 1, size)
                curr.pop()
                currSum -= nextInt
                size -= 1
                
        answers = []

        curr = []
        currSum = 0
        nextIntBegin = 1 # out of 1 through 9 allowed numbers, start with the lowest which is 1
        size = 0 # curr is empty
        backtrack(curr, currSum, nextIntBegin, size)
        
        return answers
        
